/**
 * Unit tests for NetworkLoader class
 * Tests JSON network loading and parsing
 *
 * Note: Road IDs are auto-generated by the Road constructor,
 * so JSON IDs are used for connections but roads get new IDs.
 */

#include <gtest/gtest.h>
#include "../mapping/network_loader.h"
#include "../core/road.h"
#include <fstream>
#include <filesystem>
#include <algorithm>

using namespace mapping;
using namespace simulator;

class NetworkLoaderTest : public ::testing::Test {
protected:
    std::string testJsonPath_;
    std::string invalidJsonPath_;
    std::string malformedJsonPath_;
    std::string networkInfoPath_;

    void SetUp() override {
        // Create temporary test files
        testJsonPath_ = "/tmp/test_network.json";
        invalidJsonPath_ = "/tmp/nonexistent.json";
        malformedJsonPath_ = "/tmp/malformed.json";
        networkInfoPath_ = "/tmp/network_info.json";

        // Create a valid test JSON file
        std::ofstream valid(testJsonPath_);
        valid << R"({
            "roads": [
                {
                    "id": 1,
                    "length": 500.0,
                    "lanes": 2,
                    "maxSpeed": 20,
                    "startLon": -122.4,
                    "startLat": 37.7,
                    "endLon": -122.3,
                    "endLat": 37.8
                },
                {
                    "id": 2,
                    "length": 300.0,
                    "lanes": 3,
                    "maxSpeed": 25,
                    "startLon": -122.3,
                    "startLat": 37.8,
                    "endLon": -122.2,
                    "endLat": 37.9
                }
            ],
            "intersections": [],
            "connections": []
        })";
        valid.close();

        // Create network info JSON (matches actual expected format)
        std::ofstream infoFile(networkInfoPath_);
        infoFile << R"({
            "name": "Test Network",
            "version": "1.0",
            "bbox": [-122.5, 37.5, -122.0, 38.0],
            "stats": {
                "totalRoads": 2,
                "totalIntersections": 1,
                "totalConnections": 4
            },
            "roads": [
                {"id": 1, "length": 500.0, "lanes": 2, "maxSpeed": 20},
                {"id": 2, "length": 300.0, "lanes": 3, "maxSpeed": 25}
            ]
        })";
        infoFile.close();

        // Create malformed JSON
        std::ofstream malformed(malformedJsonPath_);
        malformed << "{ this is not valid JSON }}}";
        malformed.close();
    }

    void TearDown() override {
        // Clean up test files
        std::filesystem::remove(testJsonPath_);
        std::filesystem::remove(malformedJsonPath_);
        std::filesystem::remove(networkInfoPath_);
    }
};

// LoadFromJson tests
TEST_F(NetworkLoaderTest, LoadFromJson_ValidFile) {
    auto roads = NetworkLoader::loadFromJson(testJsonPath_);
    EXPECT_EQ(roads.size(), 2);
}

TEST_F(NetworkLoaderTest, LoadFromJson_CorrectRoadProperties) {
    auto roads = NetworkLoader::loadFromJson(testJsonPath_);
    ASSERT_EQ(roads.size(), 2);

    // Roads have auto-generated IDs, but we can check other properties
    // Find the road with length 500
    auto it = std::find_if(roads.begin(), roads.end(),
        [](const Road& r) { return r.getLength() == 500.0; });

    ASSERT_NE(it, roads.end());
    EXPECT_EQ(it->getLanesNo(), 2);
}

TEST_F(NetworkLoaderTest, LoadFromJson_NonExistentFile) {
    EXPECT_THROW(
        NetworkLoader::loadFromJson(invalidJsonPath_),
        std::exception
    );
}

TEST_F(NetworkLoaderTest, LoadFromJson_MalformedJson) {
    EXPECT_THROW(
        NetworkLoader::loadFromJson(malformedJsonPath_),
        std::exception
    );
}

// LoadIntoCityMap tests
TEST_F(NetworkLoaderTest, LoadIntoCityMap_PopulatesMap) {
    std::map<roadID, Road> cityMap;
    NetworkLoader::loadIntoCityMap(testJsonPath_, cityMap);

    // Should have 2 roads
    EXPECT_EQ(cityMap.size(), 2);
}

TEST_F(NetworkLoaderTest, LoadIntoCityMap_ClearsExisting) {
    std::map<roadID, Road> cityMap;

    // Add an existing road
    Road existing(100, 200.0, 1, 15);
    cityMap[existing.getId()] = existing;
    EXPECT_EQ(cityMap.size(), 1);

    // loadIntoCityMap clears the map first
    NetworkLoader::loadIntoCityMap(testJsonPath_, cityMap);

    // Should only have the 2 roads from JSON (existing was cleared)
    EXPECT_EQ(cityMap.size(), 2);
}

// GetNetworkInfo tests
TEST_F(NetworkLoaderTest, GetNetworkInfo_ReturnsMetadata) {
    NetworkLoader::NetworkInfo info = NetworkLoader::getNetworkInfo(networkInfoPath_);

    EXPECT_EQ(info.name, "Test Network");
    EXPECT_EQ(info.version, "1.0");
}

TEST_F(NetworkLoaderTest, GetNetworkInfo_ReturnsBbox) {
    NetworkLoader::NetworkInfo info = NetworkLoader::getNetworkInfo(networkInfoPath_);

    EXPECT_DOUBLE_EQ(info.bboxMinLon, -122.5);
    EXPECT_DOUBLE_EQ(info.bboxMinLat, 37.5);
    EXPECT_DOUBLE_EQ(info.bboxMaxLon, -122.0);
    EXPECT_DOUBLE_EQ(info.bboxMaxLat, 38.0);
}

TEST_F(NetworkLoaderTest, GetNetworkInfo_CountsRoads) {
    NetworkLoader::NetworkInfo info = NetworkLoader::getNetworkInfo(networkInfoPath_);
    EXPECT_EQ(info.totalRoads, 2);
}

TEST_F(NetworkLoaderTest, GetNetworkInfo_NonExistentFile) {
    EXPECT_THROW(
        NetworkLoader::getNetworkInfo(invalidJsonPath_),
        std::exception
    );
}

// Edge cases
TEST_F(NetworkLoaderTest, LoadFromJson_EmptyRoadsArray) {
    std::string emptyRoadsPath = "/tmp/empty_roads.json";
    std::ofstream f(emptyRoadsPath);
    f << R"({
        "roads": [],
        "intersections": [],
        "connections": []
    })";
    f.close();

    auto roads = NetworkLoader::loadFromJson(emptyRoadsPath);
    EXPECT_TRUE(roads.empty());

    std::filesystem::remove(emptyRoadsPath);
}
